h1. Sibilant

Sibilant is a language that is parsed by javascript and compiles to javascript.
Sibilant is inspired by lisp and follows many lisp conventions, although it is still relatively close to the underlying javascript.
Macros can be defined in sibilant and included at compile time.
Sibilant is entirely written in sibilant and can recompile itself.

h2. Try it before you install

"sibilantjs.info":http://sibilantjs.info includes an in-browser as-you-type sibilant compiler and tutorial, so you can get a sense of the language without leaving your browser.

Note that the tutorial is for "upstream sibilant":https://github.com/jbr/sibilant, not the evanrmurphy fork.

h2. Installation

First, install "node.js":http://nodejs.org [ "github":http://github.com/ry/node ] and "npm":http://npmjs.org [ "github":http://github.com/isaacs/npm ].

@$ npm install sibilant@

h2. CLI

<pre><code>
-v / --version         Print out a version string and exit

-h / --help            This message

--repl / [no args]     Sibilant interactive command prompt

--execute / -x         This is a flag. Execute input files in order supplied.

--eval [optional STRING] / -e [optional STRING]
                       Evaluate STR if provided, otherwise evaluate standard in.

--output DIR / -o DIR  Output input files to this dir, replacing .lisp with .js.

--input FILE / -i FILE / FILE
                       Add this file to the input files. If the execute flag is
                       set, input files will be executed.  If an output dir is
                       specified, each file will be written to that dir.
                       Otherwise, each file will be written to STDOUT.

To pass arguments to an executed file, append them after a "--", as follows:
$ sibilant -x myfile.lisp -- --arg-for-my-program=stuff

myfile.lisp will see process.argv as
[ 'sibilant', 'myfile.lisp', '--arg-for-my-program=stuff' ]

</code></pre>

h3. CLI Examples

h4. To compile sibilant

<pre><code>
$ git clone git://github.com/jbr/sibilant.git
$ cd sibilant
$ npm link .
$ sibilant src/*.lisp -o lib
$ sibilant -x test/test.lisp # you're now running a sibilant you just compiled.
</code></pre>

h4. To compile one file to stdout

@$ sibilant test/test.lisp@

h4. To compile a file to a directory

@$ sibilant test/test.lisp -o . # put test.js here@ or @$ sibilant --input test/test.lisp --output .@

h4. To run a file

@$ sibilant -x test/test.lisp@

h4. To enter the repl

@$ sibilant@ or @$ sibilant --repl@

h2. Language

h3. Literals

h4. Strings

<pre><code>"to the world, he said \"hello\""</code></pre>

Multiline strings are okay:

<pre><code>"this is a
multiline string"</code></pre>

h4. Numbers

Numbers are directly translated to javascript. Valid numbers include @10@, @98.6@, @-100@, et cetera.

h4. Variables

Variables only include lower-case letters.  Hyphens are legal, and are translated into camelcase in javascript.  For example, @j-query@ is @jQuery@.  Variables can contain numbers, but cannot begin with them.  Asterisks become underscores.  For example @*global-variable*@ would become @_globalVariable_@ in javascript.  Variables can _end_ with a question mark or with an exclamation mark.  These are translated to javascript as "__QUERY" and "__BANG" (for bang).  For example, @ready?@ becomes @ready__QUERY@ and @finish!@ becomes @finish__BANG@.  I'm open to suggestions on better ways to translate ! and ? to javascript.

h3. Quoting

<pre><code>'(a b c d e f g) ;=> ['a', 'b', 'c', 'd', 'e', 'f', 'g']
'hello ;=> "hello"</code></pre>

h3. Arrays

<pre><code>[1 2 3 4 5] ;=> [1,2,3,4,5]</code></pre>


h3. Defining a variable

<pre><code>(var foo "foo now has this value")</code></pre>

h3. Hashes

<pre><code>{key1 'value1  key2 'value2} ;=> {key1: "value1", key2: "value2"}</code></pre>

h3. Calling functions

Let's say we're in node and want to use the built-in function @require@.

<pre><code>(var sys (require 'sys)) ;=> var sys = require("sys")</code></pre>

h3. Defining functions

<pre><code>(def square (arg1) (* arg1 arg1))
    ;=> var square = function(arg1) { return arg1 * arg1 }

(square 5)
</code></pre>

The last statement is always returned.

h4. Variable arguments (varargs)

Sibilant supports arbitrary-length arguments by way of the &rest label.  If an argument is preceded by @&rest@, any arguments beyond the named arguments will be put into the @&rest@ argument.  The @&rest@ argument *must* be the last argument currently.

<pre><code>(def another-example (a b &rest everything-else)
  (... do something with a, b and the something-else array ...))

(another-example 1)         ; this will raise an exception
(another-example 1 2)       ; a will be 1, b will be 2, and everythingElse will be []
(another-example 1 2 3 4 5) ; a will be 1, b will be 2, and everythingElse will be [3,4,5]
</code></pre>

h3. Anonymous functions

Anonymous functions are defined just like functions (with @&rest@ args, if you so desire), but with the fn keyword.

In fact, @(def name (args) body)@ is functionally equivalent to @(var name (fn (args) body))@.

h2. Control flow

h3. If

@if@ takes three arguments -- the condition that is checked, the true body, and the false body.  @if@ always has a return value, which is achieved by wrapping every @if@ statement in an anonymous self-calling function (in js).

<pre><code>(if (== 2 (+ 1 1)) 'yes 'no) ;=> the return value of this will be "yes"

; for multi-statement blocks, use do:
(if (defined? foo)
    (do
     (call-your-mom)
     (say 'hi))
  (do
    (complain "bad at examples")
    (42)))

; in this horrible example, if foo is defined, the first block will be
; called and the return value of say("hi") will be returned. If foo is
; undefined, the second block will be called and 42 will be returned.
</code></pre>

h3. When

@when@ is like the true branch of @if@, but doesn't require @do@ for multi-statement blocks.

<pre><code>(when (<= 2 rainbow-count)
  (puts "oh my god, double rainbow")
  (upload-to-youtube))
</code></pre>

h2. Examples

Check out "sibilant itself, which is written 100% in sibilant":http://github.com/evanrmurphy/sibilant/tree/master/src/ to get a sense of what's possible.
Also, check out "macros.lisp":http://github.com/evanrmurphy/sibilant/blob/master/lib/macros.lisp to see how easy it is to write new compiler macros.
